# 要件定義書: ログイン機能を追加する

**Issue:** #3
**作成日:** 2025-12-14

---

## Why - なぜその機能が必要なのか

マッチングアプリにおいて、ユーザーを識別・認証することは基本機能である。認証機能がなければ：

- ユーザーごとのプロフィール管理ができない
- マッチング履歴やメッセージ履歴を保存できない
- 不正利用を防止できない
- 男性/女性ユーザーの区別ができない

JWT認証 + リフレッシュトークン方式を採用することで、スケーラブルかつセキュアな認証基盤を構築する。

---

## UX - 提供したいユーザー体験

### サインアップ
1. ユーザーはメールアドレス、パスワード、基本プロフィール（ニックネーム、性別、生年月日）を入力してアカウントを作成できる
2. 登録後すぐにアプリを利用開始できる（メール認証は任意・後から）
3. メール認証を完了すると、アカウントの信頼性が向上する

### ログイン
1. メールアドレスとパスワードでログインできる
2. ログイン状態は30日間維持される（リフレッシュトークン有効期限）
3. 1時間操作がなくても、自動的にトークンがリフレッシュされる
4. 新しいデバイスでログインすると、以前のセッションは無効化される（1アカウント1セッション）

### ログアウト
1. 明示的にログアウトすることで、セッションを終了できる
2. ログアウト後、リフレッシュトークンは無効化される

---

## Issue - 解決したい課題

| 課題 | 解決方法 |
|------|----------|
| ユーザー識別ができない | Account/Userモデルで認証情報とプロフィールを管理 |
| 認証状態を維持したい | JWT + リフレッシュトークン方式で長期セッション維持 |
| セキュリティを確保したい | アクセストークン短命(1h)、リフレッシュトークンはAccountに保存 |
| 強制ログアウトしたい | Accountのリフレッシュトークンをクリアすることで実現 |
| メール確認を段階的に導入したい | is_email_verifiedフラグで任意の認証フローに対応 |

---

## Usecase - ユースケース

### UC-001: ユーザー登録（サインアップ）

**アクター:** 未登録ユーザー
**目的:** 新規アカウントを作成してアプリを利用開始する

**事前条件:**
- ユーザーがアプリにアクセスしている
- ユーザーがまだアカウントを持っていない

**基本フロー:**
1. ユーザーがサインアップ画面を開く
2. ユーザーがメールアドレスを入力する
3. ユーザーがパスワードを入力する（8文字以上、英数字混在推奨）
4. ユーザーが基本プロフィールを入力する
   - ニックネーム（必須）
   - 性別（必須: 男性/女性）
   - 生年月日（必須）
5. ユーザーが「登録」ボタンを押す
6. システムがAccountレコードとUserレコードを作成する
7. システムがアクセストークン（JWT）を生成する
8. システムがリフレッシュトークンを生成し、Accountに保存する
9. ユーザーがアプリのホーム画面に遷移する

**代替フロー:**
- 3a. メールアドレスが既に登録されている場合、エラーメッセージを表示する
- 3b. メールアドレスの形式が不正な場合、エラーメッセージを表示する
- 4a. パスワードが要件を満たさない場合、エラーメッセージを表示する

**事後条件:**
- Accountレコードが作成されている（リフレッシュトークン含む）
- Userレコードが作成され、Accountに紐づいている
- ユーザーが認証済み状態になっている

---

### UC-002: ログイン

**アクター:** 登録済みユーザー
**目的:** 既存アカウントでアプリにログインする

**事前条件:**
- ユーザーがアカウントを持っている
- ユーザーが現在ログアウト状態である

**基本フロー:**
1. ユーザーがログイン画面を開く
2. ユーザーがメールアドレスを入力する
3. ユーザーがパスワードを入力する
4. ユーザーが「ログイン」ボタンを押す
5. システムが認証情報を検証する
6. システムがアクセストークン（JWT）を生成する
7. システムがリフレッシュトークンを生成し、Accountに保存する（既存のトークンは上書き）
8. ユーザーがアプリのホーム画面に遷移する

**代替フロー:**
- 5a. メールアドレスが存在しない場合、エラーメッセージを表示する
- 5b. パスワードが間違っている場合、エラーメッセージを表示する

**事後条件:**
- Accountのリフレッシュトークンが更新されている
- ユーザーが認証済み状態になっている
- 以前のセッション（他デバイス）は無効化されている

---

### UC-003: トークンリフレッシュ

**アクター:** 認証済みユーザー（システム自動実行）
**目的:** アクセストークンを更新してセッションを維持する

**事前条件:**
- ユーザーが有効なリフレッシュトークンを持っている
- アクセストークンが期限切れ、または期限切れ間近である

**基本フロー:**
1. クライアントがリフレッシュトークンを送信する
2. システムがリフレッシュトークンをAccountのトークンと照合する
3. システムが新しいアクセストークン（JWT）を生成する
4. システムが新しいリフレッシュトークンを生成し、Accountに保存する（トークンローテーション）
5. クライアントが新しいトークンを受け取る

**代替フロー:**
- 2a. リフレッシュトークンがAccountのトークンと一致しない場合、401エラーを返す
- 2b. リフレッシュトークンが期限切れの場合、401エラーを返す

**事後条件:**
- 新しいアクセストークンが発行されている
- Accountのリフレッシュトークンが更新されている

---

### UC-004: ログアウト

**アクター:** 認証済みユーザー
**目的:** 現在のセッションからログアウトする

**事前条件:**
- ユーザーがログイン状態である

**基本フロー:**
1. ユーザーがログアウトを選択する
2. クライアントがアクセストークンを付与してログアウトAPIを呼び出す
3. システムが該当Accountのリフレッシュトークンをクリア（null）する
4. クライアント側でアクセストークンとリフレッシュトークンを破棄する
5. ユーザーがログイン画面に遷移する

**代替フロー:**
- なし

**事後条件:**
- Accountのリフレッシュトークンがnullになっている
- クライアント側のトークンが破棄されている
- ユーザーが未認証状態になっている

---

### UC-005: メール認証（任意）

**アクター:** 登録済みユーザー
**目的:** メールアドレスの所有を確認してアカウントの信頼性を高める

**事前条件:**
- ユーザーがアカウントを持っている
- ユーザーのメールが未認証状態である

**基本フロー:**
1. ユーザーがメール認証をリクエストする
2. システムが認証用トークン（有効期限付き）を生成する
3. システムが認証リンクを含むメールを送信する
4. ユーザーがメール内のリンクをクリックする
5. システムがトークンを検証する
6. システムがAccountのis_email_verifiedをtrueに更新する
7. ユーザーに認証完了を通知する

**代替フロー:**
- 5a. トークンが無効または期限切れの場合、エラーを表示して再送信を促す

**事後条件:**
- Accountのis_email_verifiedがtrueになっている

---

## Specdelta - 既存の仕様との差分

### 新規追加されるモデル

#### Accountモデル
| フィールド | 型 | 説明 |
|-----------|-----|------|
| id | UUID | 主キー |
| email | String | メールアドレス（ユニーク） |
| hashed_password | String | ハッシュ化されたパスワード |
| refresh_token | String | リフレッシュトークン（ハッシュ化、nullable） |
| refresh_token_expires_at | DateTime | リフレッシュトークン有効期限（nullable） |
| is_email_verified | Boolean | メール認証済みフラグ（デフォルト: false） |
| is_active | Boolean | アカウント有効フラグ（デフォルト: true） |
| created_at | DateTime | 作成日時 |
| updated_at | DateTime | 更新日時 |

#### Userモデル
| フィールド | 型 | 説明 |
|-----------|-----|------|
| id | UUID | 主キー |
| account_id | UUID | Accountへの外部キー（1:1） |
| nickname | String | ニックネーム |
| gender | Enum | 性別（male/female） |
| birth_date | Date | 生年月日 |
| created_at | DateTime | 作成日時 |
| updated_at | DateTime | 更新日時 |

### 新規追加されるエンドポイント

| メソッド | パス | 説明 |
|---------|------|------|
| POST | /api/v1/auth/signup | ユーザー登録 |
| POST | /api/v1/auth/login | ログイン |
| POST | /api/v1/auth/logout | ログアウト |
| POST | /api/v1/auth/refresh | トークンリフレッシュ |
| POST | /api/v1/auth/verify-email/request | メール認証リクエスト |
| POST | /api/v1/auth/verify-email/confirm | メール認証確認 |
| GET | /api/v1/users/me | 現在のユーザー情報取得 |

### 設定変更（config.py）

| 設定項目 | 現在値 | 新規値 |
|---------|--------|--------|
| access_token_expire_minutes | 30 | 60（1時間） |
| refresh_token_expire_days | - | 30（新規追加） |

### 既存コードへの影響

1. **app/core/security.py**
   - リフレッシュトークン生成関数を追加
   - 認証依存関係（get_current_user）を追加

2. **app/core/config.py**
   - refresh_token_expire_days設定を追加
   - access_token_expire_minutesのデフォルト値を60に変更

3. **app/db/base.py**
   - 変更なし（新モデルは別ファイルで定義）

4. **alembic/versions/**
   - Account, Userテーブルを作成するマイグレーションを追加
